# create the class for holding all the data associated with each design. 
# use namedtuple for memory for for what is parsed from spreedsheets and 
# fold data generated by nupack as should not change
from decimal import Decimal
import string
from tokenize import Double
from turtle import st
from typing import Dict, NamedTuple, List, Optional
from unicodedata import decimal
import pandas as pd
import sys
import openpyxl
from dataclasses import dataclass
import pandas as pd
from collections import OrderedDict
from enum import Enum

import serena.apps.original_weighted_analysis as nupackAPI

#this is the stuff that is generated by Rhijus wet lab
@dataclass
class WetlabData:
    Sequence: str = ""
    Eterna_Score: float = -1
    Baseline_Subscore: float = -1
    Folding_Subscore: float = -1
    Switch_Subscore: float = -1
    NumberOfClusters1: int = -1
    FoldChange: float = -1
    FoldChange_err_factor: float = -1
    KDOFF: float = -1
    KDON: float = -1
    ddG: float = -1
    ddG_err: float = -1

#data commonly associated with secondary structures. written with alternate structures in mind
#class structureData(NamedTuple):
#    secondaryStructure: str
#    freeEnergy: float
#    deltaMfeEnergy: float  

#this is the data the generated by folding software and in this case it is nupack
class NupackFoldData(NamedTuple):
    temperature: int
    doPknot: bool
    isPknot: bool
    #mfeInfo: structureData
    #alternateStructureList: List[structureData]
    pairprobsList: List[List[float]]
    #primaryPairsList:list
    #primaryPairsSortedList: list
    #secondaryPairsList: list
    #secondaryPairsSortedList: list

#class Oligos(NamedTuple):
#    oligoSequence: str
#    oligoSequenceLenght:str
#    OligoConcentration: str

class DesignInformation(NamedTuple):
    Sequence: str
    Sequence_Length: int
    #oligosList: List[Oligos]
    DesignID: int
    Design: str
    Player: str
    Puzzle_Name: str

#entry point for each design in a puzzle/lab
class DesignPerformanceData(NamedTuple):    
    DesignInfo: DesignInformation
    wetlabResults: WetlabData
    #nupackFoldResults: NupackFoldData

#entry point to puzzle or lab as we call them
class puzzleData(NamedTuple):
    Puzzle_Name: str
    designsList: List[DesignPerformanceData]
    designsDict: Dict[str, DesignPerformanceData]


#class RoundData(NamedTuple):
#    roundName: str
#    roundID: int
#    puzzleLabList: List[puzzleData]

       

# for each design entry we make a DesignData object and add that to a Lst once that is done 
# we add it to a puzzleData object and once that is done for all the puzzles we then add it to a round data and wea re finished.
# I think round data should be changable
class Sara2API():

    def __init__(self) -> None:
        pass

    def GetNamesClass(self, className):
        variables = [i for i in vars(className).keys() if not callable(i) and not i.startswith('__') ]
        #variables = list(vars(className).keys())
        return variables

    def openExcelWetlab(self, path, designRoundSheet):
        #$designRound = "Round 7 (R101)"
        pnasPath = r'pnas.2112979119.sd01.xlsx'
        designRound = "Round 7 (R101)"
        roundData = ['DesignID', 'Design', 'Player', 'Puzzle_Name', 'Eterna_Score', 'FoldChange', 'Sequence']
        sheet = pd.read_excel(path, sheet_name=designRoundSheet).itertuples()
        return sheet

    def GenerateNupackEntry(self, wetlabDataObject: WetlabData, temperature, doPknot):
        #now need to run each design through nupack
        #pairProbsList = List[List[float]]
        pairProbsList = nupackAPI.GetPairProbs2DArray(wetlabDataObject.Sequence, 'rna95-nupack3', temperature)
        
        isPknot=False
        if doPknot is False:
            isPknot=False
        else:
            doPknot=True
        
        nupackEntry = NupackFoldData(temperature=temperature, doPknot=doPknot, isPknot=isPknot, pairprobsList=pairProbsList)
        return nupackEntry

    def GetSetValue(self, getObject, variableSeek, setObject):
        value = getattr(getObject, variableSeek)
        setattr(setObject, variableSeek, value)
        return setObject

    def GenerateWetlabEntry(self, row: NamedTuple):
        wetlab = WetlabData
        #this is a list of the variable names from the wetlab class
        variables = self.GetNamesClass(WetlabData)
        for variable in variables:
            #sourceValue = getattr(row, variable)
            #setattr(wetlab, variable, sourceValue)
            wetlab =  self.GetSetValue(row, variable, wetlab)
        #for name, value in WetlabData.__dict__().items():
        #    wetlab =  GetSetValue(row, name, wetlab)
        #all the contents of the wetlab excel should now be loaded into wetlabData object wetlab
        #return it then
        return wetlab


    def GenerateDesignInfo(self, row: NamedTuple):
        designInfo = DesignInformation
        #this is a list of the variable names from the wetlab class
        members = self.GetNamesClass(DesignInformation)
        for variable in members:
            self.GetSetValue(row, variable, designInfo)
        return designInfo
        

    def ProcessLab(self, path, designRound_sheet):
        sheet = self.openExcelWetlab(path, designRound_sheet)
        #first do the Design entry stuff  

        designs: List[DesignPerformanceData] = []
        designsDict: Dict[str, DesignInformation] = {}
        
        for row in sheet:
            wetlabResults: WetlabData
            #nupackRestuls: NupackFoldData
            desingInfo: DesignInformation
            # this is a single line from teh file and representas a single design. load this into wetlabdata
            # and then do nupack. each row is in a namedtouple formate
            wetlabResults = self.GenerateWetlabEntry(row)
            #nupackRestuls = GenerateNupackEntry(wetlabResults, 37, False)
            desingInfo = self.GenerateDesignInfo(row)
            DesingData = DesignPerformanceData(DesignInfo=desingInfo, wetlabResults=wetlabResults)
            designs.append(DesingData)
            designsDict[DesingData.DesignInfo.DesignID]=DesingData
        puzzlename = designs[0].DesignInfo.Puzzle_Name
        #lets stop at puzzle data until this is fully gigure out and tested a bit
        puzzleInfo = puzzleData(Puzzle_Name=puzzlename, designsList=designs, designsDict=designsDict)    
        return puzzleInfo



    #this will give a list of pairs based on prob level
    def NucProbSearch(self, foldData: NupackFoldData, probThresh):
        pairsList = foldData.pairprobsList
        snuppPairsDict= dict(string, float)
        snuppList = []

        for i in range(len(pairsList)):        
            for j in range(len(pairsList[i])):
                pairValue = pairsList[i][j]
                if pairValue >= probThresh:
                    #pair = NucPair(i,j)
                    pairName = "{i}:{j}".format(i=i, j=j)
                    snuppPairsDict[pairName]=pairValue
                    snuppList.append(pairName)
        return snuppPairsDict, snuppList     


class NucPair(object):

    def __init__(self, nuc1: int, nuc2: int, pairProb:float)-> None:
        #convert to comon i, j pair
        self._i = nuc1
        self._j = nuc2
        self._pair = f'{self.i_nuc}:{self.j_nuc}'
        self._probability=pairProb
    
    def __str__(self) -> str:
        return self._pair
    
    def __repr__(self):
        return f'{self._pair}#{self._probability}'

    @property
    def i(self):
        return self._i

    @property
    def j(self):
        return self._j

    @property
    def probability(self):
        return self._probability

class NucPairList(object):
    
    def __init__(self, _nucs:List[NucPair]) -> None:
        self.currentProabilityList : List[NucPair] = _nucs
        pass
        
    def __add__(self):
        pass
        
    def makeProbDict(self):
        pass

class SearchProtocol(Enum):
    FOLDCHANGE = 1
    PAIRPROB = 2
    NUCPAIR = 3

class NupackFoldDataEnum(Enum):
    PAIRPROBS = 1
    #NOT IMPLEMENTED YET
    PAIRSLIST =2

class GenerateRainbowStructurePlot:

    def __init__(self, _searchType: SearchProtocol, _sourceType: NupackFoldDataEnum) -> None:
        self.searchType: SearchProtocol = _searchType
        self.sourceType: NupackFoldDataEnum = _sourceType
        self.initialize()

    def initialize(self):
        if self.searchType==SearchProtocol.FOLDCHANGE:
            if self.sourceType == NupackFoldDataEnum.PAIRPROBS: 
                #load fold change for lab into memory
                pass
        pass

    #this will load a datatype for furute searches to be faster
    def LoadLab(self, _lab: puzzleData):
        self.rawLabData=_lab
        self.foldChangeDict: Dict[float, Dict[float, List[NucPair]]]={}
        if self.searchType==SearchProtocol.FOLDCHANGE:
            for design in _lab.designsList:
                nupackData = design.nupackFoldResults
                wetlabData = design.wetlabResults
                currentPairDict, currentPairsList = self.PairsSearch_SingleDesign(nupackData, 0)
                currentFoldChange = wetlabData.FoldChange


    #this is agrouping and what defines a grouping is done by the function that calls this
    @dataclass
    class SearchResultsGrouping:
        _RawResults_Dict: Dict = {}
        _SortedResults_Dict: Dict = {}
        Prob_Pair: OrderedDict[float, List[NucPair]] = {}

       


    def getRainbowColorMap(self):
        pass

    #find all pairs that have a parameter in common

    def writePair(self, i: int, j: int):
        pairName = "{i}:{j}".format(i=i, j=j)
        return pairName
    
  
    
    
    #this will give a list of pairs based on prob level
    #remember that nupackfolddata is for a single design for a single lab
    def PairsSearch_SingleDesign(self, foldData: NupackFoldData, probThresh:float, doInit:Optional[bool]=False):
        pairsList = foldData.pairprobsList
        
        tempSnuppPairsDict= dict(NucPair, float)        
        tempSnuppList = []
        #snuppPairsResults = self.SearchResultsGrouping

        for i in range(len(pairsList)):        
            for j in range(len(pairsList[i])):
                pairValue = pairsList[i][j]
                if pairValue >= probThresh:
                    pairName = NucPair(i,j, pairValue)
                    if doInit==True:
                        pass
                    else:
                        #pairName = "{i}:{j}".format(i=i, j=j)
                        tempSnuppPairsDict[str(pairName)]=pairValue
                        tempSnuppList.append(pairName)
        return tempSnuppPairsDict, tempSnuppList     

    #need to write a function that is used as a base class for checking a value againsta a rna stucture vs finding commonalityin structures

    def foldChangeSearch(self, roundInfo: puzzleData, foldChange_min: float, foldChange_max: float, probMin: float):
        commonPairsList=[]
        
        #i dont care about the disgn name or anything right now just the pairs
        commonFoldChangeList=[]
        for designData in roundInfo.designsList:
            #designData is everything to do with each individual design in the lab
            #get the foldchange
            if((designData.wetlabResults.FoldChange >=  foldChange_min) and (designData.wetlabResults.FoldChange<=foldChange_max) ):
                #get nuc pairs
                pairDict, pairList = self.NucProbSearch(designData.nupackFoldResults, probMin)
                #now write to the list
                commonFoldChangeList.append(pairList)
        
        #now should have all the lists of pairs so do intersection and return just the pairs that are in common
        commonPairsList = list(set.intersection(*map(set, commonFoldChangeList)))
        return commonPairsList
        


    # make this have a argument passed that define sget/set
    def FindPairs(self, roundInfo: puzzleData, wetLabElement: string, wetLabElement_min: float, wetLabElemt_max: float, probMin: float):
        #do a search 
        #initially do fold change, no. of clusters, and EternScores
        if wetLabElement is "foldchange":
            pairsList = self.foldChangeSearch(roundInfo, wetLabElement_min, wetLabElemt_max, probMin)
        return pairsList